<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="style-util.html">
<script>
Polymer.ApplyShim = (function(){
  'use strict';

  var styleUtil = Polymer.StyleUtil;

  var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
  var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
  var VAR_MATCH = styleUtil.rx.VAR_MATCH;
  var APPLY_NAME_CLEAN = /;\s*/m;

  // map of mixin to property names
  // --foo: {border: 2px} -> (--foo, ['border'])
  var mixinMap = {};

  function mapSet(name, prop) {
    name = name.trim();
    mixinMap[name] = prop;
  }

  function mapGet(name) {
    name = name.trim();
    return mixinMap[name];
  }

  // return properties that are not used by the new definition of a mixin
  // diff([a, b], [b]) -> [a]
  function diff(oldSet, newSet) {
    var diff = [];
    if (oldSet && oldSet.length) {
      for (var i = 0, old; i < oldSet.length; i++) {
        old = oldSet[i];
        if (newSet.indexOf(old) === -1) {
          diff.push(old);
        }
      }
    }
    return diff;
  }

  //
  function flattenMixin(mixinName, propNames, propMap, resetProps) {
    var out = [];
    var i, p, v;
    // reset variables that are overriden by the current mixin
    for (i = 0; i < resetProps.length; i++) {
      p = resetProps[i];
      out.push(mixinName + '-' + p + ': initial');
    }
    // set variables defined by current mixin
    for (i = 0; i < propNames.length; i++) {
      p = propNames[i];
      v = propMap[p];
      out.push(mixinName + '-' + p + ': ' + v);
    }
    return out.join(';\n');
  }

  function applyVars(mixinName, propNames, fallbacks) {
    return propNames.map(function(p) {
      var fallback = fallbacks && fallbacks[p];
      var parts = [p, ': var(', mixinName, '-', p];
      if (fallback) {
        parts.push(',', fallback);
      }
      parts.push(')');
      return parts.join('');
    }).join(';\n');
  }

  function textToProps(text) {
    var props = text.split(';');
    var out = {};
    for (var i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        if (sp.length >= 2) {
          out[sp[0].trim()] = sp.slice(1).map(function(n) {
            return n.trim();
          }).join(':');
        }
      }
    }
    return out;
  }

  function assign(matchText, propertyName, valueProperty, valueMixin) {
    // handle case where property value is a mixin
    if (valueProperty) {
      VAR_MATCH.lastIndex = 0;
      var m = VAR_MATCH.exec(valueProperty);
      if (m) {
        var value = m[2];
        if (mapGet(value)){
          valueMixin = '@apply ' + value + ';';
        }
      }
    }
    if (!valueMixin) {
      return matchText;
    }
    valueMixin = consumeMixins(valueMixin);
    var prefix = matchText.slice(0, matchText.indexOf('--'));
    var mixinProps = textToProps(valueMixin);
    var propNames = Object.keys(mixinProps);
    var oldProps = mapGet(propertyName);
    var resetProps = diff(oldProps, propNames);
    mapSet(propertyName, propNames);
    return prefix + flattenMixin(propertyName, propNames, mixinProps, resetProps);
  }

  function apply(matchText, mixinName, fallbacks) {
    var prefix = matchText.slice(0, matchText.indexOf('@apply'));
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    var vars = '';
    var mixin = mapGet(mixinName);
    if (mixin) {
      vars = applyVars(mixinName, mixin, fallbacks) + ';';
    }
    return prefix + vars;
  }

  function collectDefaultsBeforeApply(fullText) {
    // search for properties from last @apply up to (but not including) this @apply
    var applyPos = fullText.indexOf('@apply');
    // find props defined before this @apply, after last @apply
    var textBeforeApply = fullText.slice(0, applyPos);
    return textToProps(textBeforeApply);
  }

  // fix shim'd var syntax
  // var(--a, --b) -> var(--a, var(--b));
  function fixVars(matchText, prefix, value, fallback) {
    if (!fallback || fallback.indexOf('--') !== 0) {
      return matchText;
    }
    return prefix + 'var(' + value + ',var(' + fallback + '));';
  }

  function consumeMixins(text) {
    var m, matchText, mixinName;
    MIXIN_MATCH.lastIndex = 0;
    while((m = MIXIN_MATCH.exec(text))) {
      matchText = m[0];
      mixinName = m[1];
      var defaults = collectDefaultsBeforeApply(text);
      text = text.replace(matchText, apply(matchText, mixinName, defaults));
    }
    return text;
  }

  var ApplyShim = {
    _map: mixinMap,
    transform: function(styles) {
      styleUtil.forRulesInStyles(styles, this._boundTransformRule);
    },
    transformRule: function(rule) {
      rule.cssText = this.transformCssText(rule.parsedCssText);
      // :root was only used for variable assignment in property shim,
      // but generates invalid selectors with real properties.
      // replace with `:host > *`, which serves the same effect
      if (rule.selector === ':root') {
        rule.selector = ':host > *';
      }
    },
    transformCssText: function(cssText) {
      // fix shim variables
      cssText = cssText.replace(VAR_MATCH, fixVars);
      // produce variables
      cssText = cssText.replace(VAR_ASSIGN, assign);
      // consume mixins
      return consumeMixins(cssText);
    }
  };

  ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
  return ApplyShim;
})();
</script>
